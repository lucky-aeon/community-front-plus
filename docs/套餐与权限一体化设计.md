# 套餐与权限一体化设计（前后端技术方案）

本文档面向当前“付费社区”项目，提出一套以“套餐 → 权限（课程/菜单/接口）→ 前端交互”为核心的统一方案，覆盖“能看哪些课程、能点哪些菜单、能调哪些接口”的完整链路。结合现有前端代码结构与已完成的“套餐绑定课程”能力，明确后续改造路径与里程碑。

## 背景与目标

- 背景：现有前端以 `membershipTier`（basic/premium/vip）进行部分 UI 标识，已具备后台“套餐管理 + 套餐绑定课程”的功能（见 `src/apps/admin-backend/components/SubscriptionPlansPage.tsx` 与 `src/shared/services/api/subscription-plan-courses.service.ts`）。但尚未建立统一的“权限（menus/apis/courses）”机制。
- 目标：
  - 建立稳定的“权限码（PermissionCode）”规范，支撑课程、菜单、接口的统一鉴权与前端交互。
  - 后端对接口强制鉴权；前端基于权限集进行路由/菜单/按钮的可见、可点、锁定态处理，提供升级引导。
  - 兼容现有“套餐绑定课程”，平滑扩展到“套餐绑定权限（菜单、接口）”。

## 核心概念与模型

### 权限码命名规范

建议采用分段命名 `<资源域>:<动作>:<标识>`：

- 课程：`course:view:<courseId>` 或 `course:view:*`（全量访问）
- 菜单：`menu:access:<menuKey>`（如 `menu:access:dashboard.courses`、`menu:access:admin.users`）
- 接口：`api:<method>:<key>`（如 `api:get:posts.list`、`api:post:admin.user.create`）

扩展：

- 支持通配：`*` 表示该段任意；也可通过后台在聚合时展开为具体列表以提高可解释性。
- 建议对“专题/分类”类课程引入范围型标识（可选）：`course:view:cat:<categoryId>`。

### 数据关系（后端）

- 套餐（plan）N–N 权限（permission）：`plan_permissions(plan_id, permission_id)`
- 用户（user）N–N 套餐（user_plans）：含有效期/状态；最终权限随套餐有效期变化
- 可选用户补丁：`user_overrides(user_id, permission_id, type=GRANT|REVOKE)`
- 可选资源表：`menus(id,key,title,route,...)`、`api_resources(id,key,method,path,...)`（便于后台管理与审计）

### 生效规则

用户最终权限 = 有效套餐权限并集 ∪ 用户直接授予 − 用户直接剔除。

## 后端设计（含表结构与代码）

### 技术栈对齐

- 框架：Spring Boot + Spring MVC + MyBatis-Plus
- 现状：已通过 `UserContextInterceptor` 基于 JWT 强制鉴权（/api/** 需登录），未落地细粒度权限；已具备“套餐管理”“套餐绑定课程”。
- 目标：引入“通用权限码 + 注解化鉴权 + 权益聚合”，并保持与既有订阅/课程绑定模型兼容。

### 鉴权与会话

- 登录后，后端聚合用户“权限集（permissions: string[]）”，连同基础资料一并返回。
- 建议提供 `GET /api/auth/me`（或复用 `GET /api/user`）返回：

```json
{
  "id": "u_...",
  "name": "...",
  "email": "...",
  "entitlements": {
    "permissions": ["menu:access:dashboard.courses", "course:view:123", "api:get:posts.list"],
    "courseIds": ["123","456"],
    "menuKeys": ["dashboard.courses","dashboard.discussions"],
    "updatedAt": "2025-09-20T12:00:00Z"
  }
}
```

- 缓存：将权限集缓存到会话或 JWT 中；当后台调整套餐/权限后，通过“版本号/更新时间”强制前端刷新（下次 401/403 或主动轮询/通知触发刷新）。

### 接口鉴权

- 控制器/路由标注所需权限码（自定义注解 `@RequirePermissions({"api:get:admin.users"})`）。
- 课程接口统一要求 `course:view:<id>`（或 `course:view:*`）。
- 使用 AOP 切面在调用前做权限校验；无权限抛出 403。
- 所有数据访问以服务端鉴权结果为准，前端仅做体验优化。

### 管理端 API（在现有能力基础上新增）

- 已有：
  - `GET/POST/PUT/DELETE /api/admin/subscription-plans`（套餐管理）
  - `GET/PUT /api/admin/subscription-plan-courses/:planId`（套餐↔课程绑定）
- 新增（建议）：
  - `GET /api/admin/permissions`：权限码清单（含资源域/描述）
  - `GET /api/admin/plan-permissions/:planId`：获取套餐绑定的权限码列表
  - `PUT /api/admin/plan-permissions/:planId`：全量更新套餐的权限码列表
  - 可选：`GET /api/menus` 返回菜单树（含 `requiredPermission`），也可直接在后端过滤返回可见菜单

### 审计与可观测

### 关键业务流程（注册→CDK激活→权益生效）

1) 用户注册
- 已实现：`DefaultSubscriptionEventListener` 监听 `UserRegisteredEvent`，读取系统配置 `DEFAULT_SUBSCRIPTION_PLAN`，自动创建“免费套餐”订阅记录。
- 聚合：注册完成后，用户即刻拥有免费套餐对应的菜单/接口/课程权益（通过聚合服务计算）。

2) 用户激活 CDK（套餐/课程）
- 入口：`POST /api/user/subscription/activate-cdk`（已存在）
- 建议调整：返回值包含最新 `entitlements`，避免前端再发一次 `/api/user`。

返回示例：
```json
{
  "code": 200,
  "message": "激活成功",
  "data": {
    "entitlements": {
      "permissions": ["menu:access:dashboard.courses", "course:view:123", "api:get:posts.list"],
      "courseIds": ["123","456"],
      "menuKeys": ["dashboard.courses","dashboard.discussions"],
      "updatedAt": "2025-09-20T12:00:00Z"
    }
  }
}
```

- 流程（套餐CDK）：校验CDK→创建订阅记录→（事件）→聚合或失效缓存→返回新权益
- 流程（课程CDK）：校验CDK→`UserDomainService.grantCourseToUser`→（事件）→聚合或失效缓存→返回新权益

3) 到期/降级
- `user_subscriptions` 到期或主动降级后，聚合结果自动减少；使用缓存时应在状态变更时清理对应用户缓存。

4) 缓存与一致性
- 建议在 `PermissionAggregationAppService.aggregate(userId)` 外层加本地/Redis缓存，Key：`entitlements:{userId}`，TTL 15~60 分钟。
- 在以下时机失效缓存：CDK激活成功、订阅创建/更新、用户覆盖变更、套餐-权限/菜单/课程绑定更新。

- 记录 403 拒绝日志（账号、接口、所需权限、用户实际权限快照），便于快速排障。

### 数据库表结构（MySQL 8+）

说明：兼容现有表 `user_subscriptions`、`subscription_plans`、`subscription_plan_courses`。新增“通用权限码绑定 + 菜单绑定 + 用户覆盖”。

1) 通用权限码表（可选，便于后台维护）

```sql
CREATE TABLE `permissions` (
  `id`           BIGINT PRIMARY KEY AUTO_INCREMENT,
  `code`         VARCHAR(128) NOT NULL UNIQUE COMMENT '权限码，如 menu:access:admin.users',
  `resource`     VARCHAR(32)  NOT NULL COMMENT '资源域：menu/api/course',
  `action`       VARCHAR(32)  NULL     COMMENT '动作：access/get/post/view 等',
  `subject`      VARCHAR(128) NULL     COMMENT '主体：菜单key / 接口key / 课程ID或*',
  `description`  VARCHAR(255) NULL,
  `created_at`   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at`   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) COMMENT='通用权限码定义';
```

2) 套餐→权限码绑定（接口/通用权限）

```sql
CREATE TABLE `subscription_plan_permissions` (
  `id`           BIGINT PRIMARY KEY AUTO_INCREMENT,
  `plan_id`      CHAR(36) NOT NULL,
  `permission_code` VARCHAR(128) NOT NULL,
  `created_at`   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY `uk_plan_perm`(`plan_id`,`permission_code`),
  KEY `idx_perm_code`(`permission_code`)
) COMMENT='套餐绑定的通用权限码（含接口等）';
```

3) 套餐→菜单绑定（展示/可见性/交互控制）

```sql
CREATE TABLE `subscription_plan_menus` (
  `id`           BIGINT PRIMARY KEY AUTO_INCREMENT,
  `plan_id`      CHAR(36)   NOT NULL,
  `menu_key`     VARCHAR(64) NOT NULL COMMENT '如 dashboard.courses / admin.users',
  `created_at`   DATETIME   NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE KEY `uk_plan_menu`(`plan_id`,`menu_key`),
  KEY `idx_menu_key`(`menu_key`)
) COMMENT='套餐绑定的菜单访问权';
```

4) 用户权限覆盖（个性化加权/剔除）

```sql
CREATE TABLE `user_permission_overrides` (
  `id`           BIGINT PRIMARY KEY AUTO_INCREMENT,
  `user_id`      CHAR(36)      NOT NULL,
  `permission_code` VARCHAR(128) NOT NULL,
  `op`           ENUM('GRANT','REVOKE') NOT NULL,
  `reason`       VARCHAR(255)  NULL,
  `created_at`   DATETIME      NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at`   DATETIME      NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  UNIQUE KEY `uk_user_perm`(`user_id`,`permission_code`)
) COMMENT='用户层面权限补丁';
```

注：课程访问仍复用现有 `subscription_plan_courses(plan_id, course_id)` 与“用户直接拥有课程”的能力。

### MyBatis-Plus 实体与仓库（示例）

实体（省略 getter/setter）：

```java
// package org.xhy.community.domain.permission.entity;
@TableName("subscription_plan_permissions")
public class SubscriptionPlanPermissionEntity {
  @TableId(type = IdType.AUTO) private Long id;
  private String planId;
  private String permissionCode;
  private LocalDateTime createdAt;
}

@TableName("subscription_plan_menus")
public class SubscriptionPlanMenuEntity {
  @TableId(type = IdType.AUTO) private Long id;
  private String planId;
  private String menuKey;
  private LocalDateTime createdAt;
}

@TableName("user_permission_overrides")
public class UserPermissionOverrideEntity {
  @TableId(type = IdType.AUTO) private Long id;
  private String userId;
  private String permissionCode;
  private String op; // GRANT / REVOKE
  private LocalDateTime createdAt;
  private LocalDateTime updatedAt;
}
```

仓库：

```java
// package org.xhy.community.domain.permission.repository;
public interface SubscriptionPlanPermissionRepository extends BaseMapper<SubscriptionPlanPermissionEntity> {}
public interface SubscriptionPlanMenuRepository extends BaseMapper<SubscriptionPlanMenuEntity> {}
public interface UserPermissionOverrideRepository extends BaseMapper<UserPermissionOverrideEntity> {}
```

### 权益聚合服务（核心）

新增应用服务用于计算用户“最终权限集”和“便捷清单”（课程ID、菜单Key）：

```java
// package org.xhy.community.application.permission.service;
@Service
public class PermissionAggregationAppService {
  private final UserSubscriptionRepository userSubscriptionRepo;
  private final SubscriptionPlanCourseRepository planCourseRepo;
  private final SubscriptionPlanMenuRepository planMenuRepo;
  private final SubscriptionPlanPermissionRepository planPermRepo;
  private final UserPermissionOverrideRepository userOverrideRepo;
  private final UserDomainService userDomainService; // 直接拥有课程

  public UserEntitlements aggregate(String userId) {
    // 1) 有效订阅
    List<UserSubscriptionEntity> subs = getActiveSubscriptions(userId);
    Set<String> planIds = subs.stream().map(UserSubscriptionEntity::getSubscriptionPlanId).collect(toSet());

    // 2) 课程权限（订阅 + 直接拥有）
    Set<String> courseIds = new HashSet<>();
    if (!planIds.isEmpty()) {
      List<SubscriptionPlanCourseEntity> pcs = planCourseRepo.selectList(new LambdaQueryWrapper<SubscriptionPlanCourseEntity>()
          .in(SubscriptionPlanCourseEntity::getSubscriptionPlanId, planIds));
      pcs.forEach(x -> courseIds.add(x.getCourseId()));
    }
    userDomainService.getUserCourses(userId).forEach(courseIds::add);

    // 3) 菜单权限（订阅）
    Set<String> menuKeys = new HashSet<>();
    if (!planIds.isEmpty()) {
      List<SubscriptionPlanMenuEntity> pms = planMenuRepo.selectList(new LambdaQueryWrapper<SubscriptionPlanMenuEntity>()
          .in(SubscriptionPlanMenuEntity::getSubscriptionPlanId, planIds));
      pms.forEach(x -> menuKeys.add(x.getMenuKey()));
    }

    // 4) 通用权限码（订阅）
    Set<String> permissions = new HashSet<>();
    if (!planIds.isEmpty()) {
      List<SubscriptionPlanPermissionEntity> pps = planPermRepo.selectList(new LambdaQueryWrapper<SubscriptionPlanPermissionEntity>()
          .in(SubscriptionPlanPermissionEntity::getPlanId, planIds));
      pps.forEach(x -> permissions.add(x.getPermissionCode()));
    }

    // 5) 组合课程权限为权限码（course:view:<id>）
    courseIds.forEach(id -> permissions.add("course:view:" + id));

    // 6) 用户覆盖
    List<UserPermissionOverrideEntity> overrides = userOverrideRepo.selectList(new LambdaQueryWrapper<UserPermissionOverrideEntity>()
        .eq(UserPermissionOverrideEntity::getUserId, userId));
    overrides.forEach(o -> {
      if ("GRANT".equals(o.getOp())) permissions.add(o.getPermissionCode());
      else permissions.remove(o.getPermissionCode());
    });

    return new UserEntitlements(permissions, new ArrayList<>(courseIds), new ArrayList<>(menuKeys), LocalDateTime.now());
  }

  // 与现有 UserPermissionAppService.getActiveSubscriptions 一致
  private List<UserSubscriptionEntity> getActiveSubscriptions(String userId) { /* 参考现有实现 */ }
}

@Data @AllArgsConstructor
public class UserEntitlements {
  private Set<String> permissions;
  private List<String> courseIds;
  private List<String> menuKeys;
  private LocalDateTime updatedAt;
}
```

### 自定义权限注解 + AOP 切面

注解：

```java
// package org.xhy.community.infrastructure.security;
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermissions {
  String[] value();
  Mode mode() default Mode.ANY;
  enum Mode { ANY, ALL }
}
```

切面：

```java
@Aspect
@Component
public class PermissionAspect {
  private final PermissionAggregationAppService agg;

  public PermissionAspect(PermissionAggregationAppService agg) { this.agg = agg; }

  @Around("@annotation(requirePermissions)")
  public Object check(ProceedingJoinPoint pjp, RequirePermissions requirePermissions) throws Throwable {
    String userId = UserContext.getCurrentUserId();
    Set<String> perms = agg.aggregate(userId).getPermissions();
    String[] required = requirePermissions.value();
    boolean ok = requirePermissions.mode() == RequirePermissions.Mode.ALL
      ? Arrays.stream(required).allMatch(perms::contains)
      : Arrays.stream(required).anyMatch(perms::contains);
    if (!ok) throw new AuthorizationException(403, "权限不足");
    return pjp.proceed();
  }
}

public class AuthorizationException extends RuntimeException {
  private final int code;
  public AuthorizationException(int code, String msg) { super(msg); this.code = code; }
  public int getCode() { return code; }
}
```

在全局异常处理中补充 403：

```java
@ExceptionHandler(AuthorizationException.class)
@ResponseStatus(HttpStatus.FORBIDDEN)
public ApiResponse<Void> handleAuthz(AuthorizationException ex) {
  return ApiResponse.error(ex.getCode(), ex.getMessage()); // code=403,message=权限不足
}
```

控制器使用示例：

```java
@RestController
@RequestMapping("/api/admin/users")
public class AdminUserController {
  @RequirePermissions("api:get:admin.users")
  @GetMapping
  public ApiResponse<IPage<AdminUserDTO>> queryUsers(AdminUserQueryRequest request) { ... }

  @RequirePermissions("api:put:admin.user.update")
  @PutMapping("/{userId}/devices")
  public ApiResponse<AdminUserDTO> updateUserDevices(...) { ... }
}
```

课程接口示例：

```java
@RestController
@RequestMapping("/api/user/courses")
public class UserCourseController {
  @RequirePermissions
  ("course:view:*") // 若开放“全量课程”套餐；也可在服务层以 userId+courseId 精细判断
  @GetMapping("/{courseId}")
  public ApiResponse<CourseDetailDTO> getCourseDetail(@PathVariable String courseId) { ... }
}
```

### `/api/user` 返回结构扩展（携带 entitlements）

在 `UserAppService.getCurrentUserInfo` 中注入 `PermissionAggregationAppService`，构造返回：

```java
public UserDTO getCurrentUserInfo(String userId) {
  UserEntity user = userDomainService.getUserById(userId);
  UserDTO dto = UserAssembler.toDTO(user);
  UserEntitlements ents = permissionAggregationAppService.aggregate(userId);
  dto.setEntitlements(new UserDTO.Entitlements( // 需要在 UserDTO 中新增字段
      new ArrayList<>(ents.getPermissions()),
      ents.getCourseIds(),
      ents.getMenuKeys(),
      ents.getUpdatedAt()
  ));
  return dto;
}
```

UserDTO 扩展：

```java
public class UserDTO {
  // existing fields...
  private Entitlements entitlements;
  @Data @AllArgsConstructor
  public static class Entitlements {
    private List<String> permissions;
    private List<String> courseIds;
    private List<String> menuKeys;
    private LocalDateTime updatedAt;
  }
}
```

## 前端设计

### 数据来源与上下文

- 启动时获取 `me`：扩展 `AuthContext` 存储 `entitlements.permissions`。
- 现有：`src/context/AuthContext.tsx` 仅维护 `user/isLoading`；需要新增 `permissions: string[]` 与刷新方法。
  - 现有拦截器：`src/shared/services/api/config.ts` 已对 403 做提示，可在 403 时触发一次 `/api/auth/me` 刷新。

建议新增：

- `src/shared/constants/permissions.ts`：集中定义常见权限常量（便于 IDE 提示与统一）
- `src/shared/types/permissions.ts`：`type PermissionCode = string` + 常见资源字面量联合
- `src/hooks/usePermission.ts`：`usePermission(codes: string | string[], mode?: 'all'|'any') => boolean`
- `src/shared/components/PermissionGate.tsx`：包裹子树，未授权显示占位/锁定/升级 CTA
- `src/shared/components/LockableNavLink.tsx`：菜单/按钮的一致“锁定态+升级弹窗”交互

### 路由与页面保护

- 扩展 `ProtectedRoute` 支持权限：在 `src/shared/routes/ProtectedRoute.tsx` 基于 `requiredPerms?: string[]` 与策略 `mode?: 'all'|'any'` 判断；无权限跳转 `/403` 或展示升级页。
- 路由条目携带元信息（示例）：

```tsx
// 伪代码：在 Router 配置处
<Route
  path="/dashboard/admin/users"
  element={
    <ProtectedRoute requiredPerms={["menu:access:admin.users"]}>
      <AdminUsersPage />
    </ProtectedRoute>
  }
/>
```

### 菜单保护与交互

- 现有菜单：
  - 用户端菜单定义在 `src/shared/routes/routes.ts` 的 `navigationConfig`
  - 管理端菜单定义在 `src/apps/admin-backend/components/AdminLayout.tsx` 的 `navigationSections`
- 改造：为每项补充 `requiredPermission?: string` 与 `policy?: 'hide' | 'lock'`：

```ts
// 例：用户端
{ id: 'courses', name: '课程', path: '/dashboard/courses', icon: 'BookOpen', requiredPermission: 'menu:access:dashboard.courses', policy: 'lock' }

// 例：管理端（建议隐藏）
{ id: 'users', name: '用户列表', path: '/dashboard/admin/users', icon: Users, requiredPermission: 'menu:access:admin.users', policy: 'hide' }
```

- 渲染策略：
  - policy=hide：无权限不渲染（适用于管理/敏感功能）
  - policy=lock：显示锁定态，点击弹出升级弹窗（适用于售卖导向功能）

### 课程访问与列表锁定

- 课程页播放/下载等「动作按钮」使用 `usePermission('course:view:<id>')` 控制；
- 列表卡片可根据 `entitlements.courseIds` 提前做锁定样式（提升体验），以服务端鉴权为准。

### Axios 403 拦截与升级引导

- 已有 403 toast；扩展为：
  - 打开“升级套餐”弹窗（展示当前套餐 vs 目标功能所需权限/套餐差异）；
  - 若用户已升级成功，触发 `AuthService.refreshUserInfo()` 或 `/api/auth/me` 刷新本地 `permissions`；

## 与现状的衔接与兼容

- 保留 `membershipTier` 仅作 UI 标识；真正的访问控制以 `permissions` 为准。
- 复用/扩展现有“套餐绑定课程”后端能力：
  - 将“可看课程列表”映射为权限集（批量 `course:view:<id>`），或通过给套餐授予 `course:view:*`（全量）
- 新增“套餐绑定权限（菜单/接口）”管理页面：
  - 与 `SubscriptionPlansPage` 类似的绑定 UI（穿梭框/勾选），调用 `plan-permissions` API 更新

## 里程碑与落地顺序

M1（最小可用）
- 后端：`/api/auth/me`（或扩展 `/api/user`）返回 `entitlements.permissions`
- 前端：
  - 新增 `usePermission`、扩展 `ProtectedRoute` 支持 `requiredPerms`
  - 在 `AdminBackend` 路由与菜单上增加权限控制（默认隐藏）
  - 用户端菜单加锁定态（默认锁定 + 升级 CTA）

M2（完善）
- 后端：接口注解化鉴权（api:* 权限）；`plan-permissions` 管理接口
- 前端：
  - 新增 `PermissionGate`、`LockableNavLink`
  - `navigationConfig` 增加 `requiredPermission` 字段并接入 hook
  - 课程播放/下载按钮接入 `usePermission`

M3（体验与运维）
- 升级弹窗完善对比文案；权限变更实时刷新（websocket/短轮询）
- 403 审计日志与后台可视化

## 附：典型权限码清单（草案）

- 菜单（menu:access:*）
  - `menu:access:dashboard.home`
  - `menu:access:dashboard.discussions`
  - `menu:access:dashboard.courses`
  - `menu:access:admin.overview`
  - `menu:access:admin.users`
  - `menu:access:admin.posts`
  - `menu:access:admin.courses`
  - `menu:access:admin.settings`

- 接口（api:method:key）
  - `api:get:posts.list`, `api:get:posts.detail`, `api:post:posts.create`
  - `api:get:admin.users`, `api:post:admin.user.create`, `api:put:admin.user.update`

- 课程（course:view:*）
  - `course:view:*`（全量）或 `course:view:<id>` 列表

## 前端示例代码片段（草案）

1) `src/hooks/usePermission.ts`

```ts
import { useMemo } from 'react';
import { useAuth } from '@/context/AuthContext';

export function usePermission(codes: string | string[], mode: 'all' | 'any' = 'any') {
  const { entitlements } = useAuth();
  const required = Array.isArray(codes) ? codes : [codes];
  return useMemo(() => {
    const set = new Set(entitlements?.permissions || []);
    if (mode === 'all') return required.every(c => set.has(c));
    return required.some(c => set.has(c));
  }, [entitlements?.permissions, JSON.stringify(required), mode]);
}
```

2) 扩展 `ProtectedRoute`（节选，文件：`src/shared/routes/ProtectedRoute.tsx`）

```tsx
export const ProtectedRoute: React.FC<{ children: React.ReactNode; requiredPerms?: string[]; mode?: 'all'|'any'; }>
  = ({ children, requiredPerms, mode = 'any' }) => {
    const { user, isLoading, entitlements } = useAuth();
    if (isLoading) return <LoadingSpinner text="验证用户身份中..." />;
    if (!user) return <Navigate to="/" replace />;
    if (requiredPerms && requiredPerms.length > 0) {
      const has = usePermission(requiredPerms, mode);
      if (!has) return <Navigate to="/403" replace />; // 或升级页
    }
    return <>{children}</>;
  };
```

3) 菜单配置（文件：`src/shared/routes/routes.ts`）

```ts
export const navigationConfig = [
  { id: 'home', name: '首页', path: '/dashboard/home', icon: 'Home' },
  { id: 'discussions', name: '讨论', path: '/dashboard/discussions', icon: 'MessageSquare' },
  { id: 'courses', name: '课程', path: '/dashboard/courses', icon: 'BookOpen', requiredPermission: 'menu:access:dashboard.courses', policy: 'lock' },
];
```

渲染处判断：无权限且 policy=hide -> 不渲染；policy=lock -> 渲染锁定态。

## 开发任务清单（第一阶段）

- 后端：扩展 `/api/auth/me` 或 `/api/user` 返回 `entitlements.permissions`
- 前端：
  - `AuthContext` 增加 `entitlements: { permissions: string[] }` 与刷新方法
  - 新增 `usePermission` hook
  - 扩展 `ProtectedRoute` 支持权限判断
  - 为管理端关键路由与菜单补充 `requiredPermission`
  - 用户端“课程”菜单与播放按钮加入权限判断（锁定态 + 升级 CTA）

## 迁移与落地顺序（脚本/代码）

1) 执行新增表 DDL：`subscription_plan_permissions`、`subscription_plan_menus`、`user_permission_overrides`（如需，`permissions`）
2) 初始化核心权限码：
   - 接口权限：`api:get:admin.users`、`api:post:admin.user.create`、`api:put:admin.user.update`、`api:get:admin.courses`...
   - 菜单权限：`menu:access:dashboard.courses`、`menu:access:admin.users`...
3) 后台页面接入：在“套餐管理”旁新增“套餐-权限绑定”界面，绑定上述权限码（复用穿梭框组件）
4) 接入聚合服务 + 注解切面；为 admin 控制器标注 `@RequirePermissions`；课程接口使用 `course:view:*`/`course:view:<id>` 规则
5) `/api/user` 返回扩展 entitlements；前端接入 `usePermission` 与 `ProtectedRoute`
6) 审计：网关或切面打印 403 事件日志（用户ID、接口、所需权限、权限快照），便于排查

## 说明

- 前端所有权限判断仅用于提升体验，实际访问控制必须由服务端强制执行。
- 权限码作为“协议”稳定输出，前端不建议通过拼接接口路径动态生成。
